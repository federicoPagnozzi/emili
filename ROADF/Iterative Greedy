
irpSolution Instance::GreedySolution(){
    irpSolution solution;
    vector< vector<double> > horizonQuantities(this->customers.size());
    for(int p=0; p<this->customers.size();p++){
      if(p>1){
        vector<double> horizon(this->customers[p].getForecast().size(),0.0);
        horizonQuantities[p]=horizon;
        horizonQuantities[p][0] = 0.0 /*this->customers[p].getInitialTankQuantity()*/;
        for(int f=0; f<this->customers[p].getForecast().size(); f++){
      if(f>0){
        horizonQuantities[p][f] = horizonQuantities[p][f] + horizonQuantities[p][f-1] - this->customers[p].getForecast()[f];
      }
      else{
        horizonQuantities[p][f] -= this->customers[p].getForecast()[f];
      }
        }

      }
      else{
        vector<double> horizon(this->customers[p].getForecast().size(),0.0);
        horizonQuantities[p]=horizon;
      }
    }

    vector<double> tankQuantities(this->customers.size());
    for(int c=0; c<this->customers.size(); c++){
      if(c == 0)
         tankQuantities[c] = 0.0;
      else
        tankQuantities[c] = this->customers[c].getInitialTankQuantity();
    }

    vector<double> trailerQuantities(this->trailers.size());
    for(int t=0; t<this->trailers.size(); t++){
      trailerQuantities[t] = this->trailers[t].getInitialQuantity();
    }

     vector< pair< pair<unsigned int,unsigned int>, unsigned int > > timeWindows;
     for(int d=0; d<this->drivers.size(); d++){
       for(int t=0; t<this->drivers[d].getTimeWindows().size(); t++){
         pair< pair<unsigned int,unsigned int>, unsigned int > tw;
         tw.first = this->drivers[d].getTimeWindows()[t];
         tw.second = d;
         timeWindows.push_back(tw);
       }
     }
    this->sortPair(timeWindows);

    vector<unsigned int> lastOperations(this->customers.size(), 0.0);
    vector<double> pastQuantities(this->customers.size(), 0.0);

    /////////////////////////////

    unsigned int time = 0;

    while(timeWindows.size() > 0){
    Shift shift;
    shift.setIndex(solution.getShifts().size());


        shift.setDriver(timeWindows[0].second);
        shift.setTrailer(this->drivers[timeWindows[0].second].getTrailer());
        shift.setStart(timeWindows[0].first.first);

        time += timeWindows[0].first.first;

        vector<unsigned int> customerList;
        for(int c=0; c<this->customers.size(); c++)
        customerList.push_back(c);
        vector<double> urgency(this->customers.size(),0.0);

        double globalForecast = 0.0;
        for(int c=2; c<this->customers.size(); c++)
            for(int f=0; f<this->customers[c].getForecast().size(); f++)
                globalForecast += this->customers[c].getForecast()[f];

        for(int c=2; c<this->customers.size(); c++){
          Customer customer = this->customers[c];
          vector<double> forecast = customer.getForecast();
          double totForecast = 0;
          bool flag = true;

          double deliveredQuantity = 0.0;

          for(int s=0; s<solution.getShifts().size(); s++)
            for(int o=0; o<solution.getShifts()[s].getOperations().size(); o++)
                if(solution.getShifts()[s].getOperations()[o].getPoint() == c)
                  deliveredQuantity += solution.getShifts()[s].getOperations()[o].getQuantity();
          /////
          double totalForecast = 0.0;
          for(int f=0; f<forecast.size(); f++)
              totalForecast += forecast[f];
          /////
          unsigned int f = 0;
          while(f < forecast.size() and flag){
            totForecast += forecast[f];
            if(totForecast > deliveredQuantity + this->customers[c].getInitialTankQuantity() - this->customers[c].getSafetyLevel()){
              urgency[c] = (double)f/forecast.size();
//              urgency[c] *= (1.0 - (totalForecast - deliveredQuantity)/globalForecast);
              flag = false;
//              cout<<"Fs: "<<(double)f/forecast.size()<<" "<< totalForecast<<" "<<deliveredQuantity<<" "<<(1.0 - (totalForecast - deliveredQuantity)/globalForecast)<<" "<<globalForecast<<" "<<urgency[c]<<"\n";
//              int a;cin>>a;
            }
            f++;
          }
        }

        for(int u=0; u<urgency.size(); u++)
          if(urgency[u] <= 0){
            customerList.erase(customerList.begin() + u);
            urgency.erase(urgency.begin() + u);
            u--;
          }

        this->sort(customerList, urgency);
        customerList.insert(customerList.begin(), 0);

        /*
        for(int c=0; c<customerList.size(); c++)
          cout<<customerList[c]<<" ";
        cout<<"\n";

        for(int u=0; u<urgency.size(); u++)
          cout<<urgency[u]<<" ";
        cout<<"\n";
  */
        cout<<"SHIFT: "<<shift.getIndex()<<" start: "<<shift.getStart()<<"  \n";
        vector<Operation> operations;


        /*operations = recursiveRandomShift(solution, shift.getStart(), 0, horizonQuantities, tankQuantities, trailerQuantities,
                                          pastQuantities, lastOperations, timeWindows, customerList, operations);*/

                                bool breakFlag = false;
                                time = shift.getStart();
                                unsigned int cumTime = 0.0;
                                /////////////////////////
                        //        if(customerList.size() <= 1){
                        //          return operations;
                        //        }
                                while(customerList.size() > 1){
                        //        else{
                                 unsigned int prec, succ;
                                 prec = 0;
                                 succ = 1;

                                unsigned int twD=0;
                                bool lastDShift = true;
                                for(int t=1; t<timeWindows.size(); t++)
                                  if(timeWindows[t].second == timeWindows[0].second){
                                    twD = t;
                                    lastDShift = false;
                                    break;
                                  }
                                unsigned int twT=0;
                                bool lastTShift = true;
                                for(int t=1; t<timeWindows.size(); t++)
                                  if(this->drivers[timeWindows[t].second].getTrailer() == this->drivers[timeWindows[0].second].getTrailer()){
                                    twT = t;
                                    lastTShift = false;
                                    break;
                                  }
                                  bool allowedTrailerFlag = false;
                                  for(int t=0; t<this->customers[customerList[succ]].getAllowedTrailers().size(); t++)
                                    if(this->customers[customerList[succ]].getAllowedTrailers()[t] == this->drivers[timeWindows[0].second].getTrailer()  or customerList[succ] <= 1)
                                  allowedTrailerFlag = true;

                                  double pastQuantity = 0.0;
                                  double horizon = 0.0;
                                      if(customerList[succ]!=1){
                                          pastQuantity = pastQuantities[customerList[succ]];
                                          pastQuantity += this->customers[customerList[succ]].getInitialTankQuantity();
                                          pastQuantity += horizonQuantities[customerList[succ]][(int)(time + this->timeMatrices[customerList[prec]][customerList[succ]])/60];
                                          tankQuantities[customerList[succ]] = pastQuantity;
                                          if(tankQuantities[customerList[succ]] < 0.0)
                                              tankQuantities[customerList[succ]] = 0.0;
                                       //   unsigned int lastOperation = lastOperations[customerList[succ]];
                                          horizon = 0.0;
                                          if(customerList[succ] != 1){
                                             horizon = pastQuantity + horizonQuantities[customerList[succ]].back() - horizonQuantities[customerList[succ]][(int)(time + this->timeMatrices[customerList[prec]][customerList[succ]])/60];
                                             horizon -= this->customers[customerList[succ]].getSafetyLevel();
                                          }
                                      }

                                 while(not(
                                   cumTime + this->timeMatrices[customerList[prec]][customerList[succ]] + this->customers[customerList[succ]].getSetupTime() + this->timeMatrices[customerList[succ]][0] <= this->drivers[timeWindows[0].second].getMaxDrivingDuration()
                                   and timeWindows[0].first.first + cumTime + this->timeMatrices[customerList[prec]][customerList[succ]] + this->customers[customerList[succ]].getSetupTime() + this->timeMatrices[customerList[succ]][0] <= timeWindows[0].first.second
                                   and (timeWindows[twD].first.first - (cumTime + timeWindows[0].first.first + this->timeMatrices[customerList[prec]][customerList[succ]] + this->customers[customerList[succ]].getSetupTime() + this->timeMatrices[customerList[succ]][0]) >= drivers[timeWindows[0].second].getMinInterSHIFTDURATION()
                                     or lastDShift   )
                                   and (timeWindows[twT].first.second <= timeWindows[0].first.first or timeWindows[twT].first.first >= timeWindows[0].first.second
                                    or lastTShift    )
                                   and (allowedTrailerFlag or customerList[succ]==1)
                                   )
                                   or (tankQuantities[customerList[succ]] >= this->customers[customerList[succ]].getCapacity() and customerList[succ] != 1)
                                   or (lastOperations[customerList[succ]] >= time + this->timeMatrices[customerList[prec]][customerList[succ]]  and customerList[succ] != 1)
                                   or (horizon >= -0.0000001 and customerList[succ] != 1)
                                ) {

                                   customerList.erase(customerList.begin() + succ);
/*
                                   if(customerList.size() <=1 ){
                                     return operations;
                                   }
*/

                                   if(customerList.size() <= 1 ){
                                       breakFlag = true;
                                     break;
                                   }

                                  allowedTrailerFlag = false;
                                  for(int t=0; t<this->customers[customerList[succ]].getAllowedTrailers().size(); t++)
                                    if(this->customers[customerList[succ]].getAllowedTrailers()[t] == this->drivers[timeWindows[0].second].getTrailer() or customerList[succ] <= 1)
                                  allowedTrailerFlag = true;

                                      if(customerList[succ]!=1){
                                          pastQuantity = pastQuantities[customerList[succ]];
                                          pastQuantity += this->customers[customerList[succ]].getInitialTankQuantity();
                                          pastQuantity += horizonQuantities[customerList[succ]][(int)(time + this->timeMatrices[customerList[prec]][customerList[succ]])/60];
                                          tankQuantities[customerList[succ]] = pastQuantity;
                                          if(tankQuantities[customerList[succ]] < 0.0)
                                              tankQuantities[customerList[succ]] = 0.0;
                                       //   unsigned int lastOperation = lastOperations[customerList[succ]];
                                          horizon = 0.0;
                                          if(customerList[succ] != 1){
                                             horizon = pastQuantity + horizonQuantities[customerList[succ]].back() - horizonQuantities[customerList[succ]][(int)(time + this->timeMatrices[customerList[prec]][customerList[succ]])/60];
                                             horizon -= this->customers[customerList[succ]].getSafetyLevel();
                                           }
                                       }
                                  }
                                 if(breakFlag)
                                     break;
                                  unsigned int driver = timeWindows[0].second;
                                  unsigned int trailer = this->drivers[driver].getTrailer();
                                  unsigned int customer = customerList[succ];

                                  Operation operation;
                                  operation.setArrival(time + this->timeMatrices[customerList[prec]][customer]);

                                  if(lastOperations[customer] < time + this->timeMatrices[customerList[prec]][customer])
                                      lastOperations[customer] = time + this->timeMatrices[customerList[prec]][customer];

                                  operation.setPoint(customer);


                                  bool refuelFlag = false;


                                  cout<<"         Tank: "<<tankQuantities[customer]<<"   trail:"<<trailerQuantities[trailer]<<"   horizon: "<<horizon<<"\n";
                                  if(customer == 1){
                                    operation.setQuantity(-(this->trailers[trailer].getCapacity() - trailerQuantities[trailer]));
                                    pastQuantities[customer] += operation.getQuantity();
                                    trailerQuantities[trailer] = - operation.getQuantity();
                                  }
                                  else if(trailerQuantities[trailer] <= fabs(horizon)){
                                    double quantity = 0.0;
                                    if(trailerQuantities[trailer] <= this->customers[customer].getCapacity() - tankQuantities[customer]){
                                        quantity = trailerQuantities[trailer];
                                        refuelFlag = true;
                                    }
                                    else
                                        quantity = this->customers[customer].getCapacity() - tankQuantities[customer];

                                    pastQuantities[customer] += quantity;
                                    operation.setQuantity(quantity);
                                    trailerQuantities[trailer] -= operation.getQuantity();

                                  }
                                  else{
                                    double quantity = 0.0;
                                    if(fabs(horizon) < this->customers[customer].getCapacity() - tankQuantities[customer])
                                        quantity = fabs(horizon);
                                    else
                                        quantity = this->customers[customer].getCapacity() - tankQuantities[customer];

                                    pastQuantities[customer] += quantity;
                                    operation.setQuantity(quantity);
                                    trailerQuantities[trailer] -= operation.getQuantity();
                                  }

                                  unsigned int currentCumTime = this->timeMatrices[customerList[prec]][customer] + this->customers[customer].getSetupTime();
                                  unsigned int currentSetupTime = this->customers[customer].getSetupTime();

                                  customerList.erase(customerList.begin());
                                  customerList.erase(customerList.begin());
                                  customerList.insert(customerList.begin(), customer);
                                  operations.push_back(operation);
                                  if(refuelFlag){
                                    customerList.insert(customerList.begin() + 1, 1);
                                  }

                                  cout<<"     Operation: "<<operation.getPoint()<<"   arr: "<<operation.getArrival()<<"   q: "<<operation.getQuantity()<<"\n";

                        //          return recursiveRandomShift(
                        //            solution,
                        //            operation.getArrival() + currentSetupTime,
                        //            cumTime + currentCumTime,
                        //            horizonQuantities, tankQuantities, trailerQuantities, pastQuantities, lastOperations,
                        //            timeWindows, customerList, operations);
                                  time = operation.getArrival() + currentSetupTime;
                                  cumTime += currentCumTime;
                                }


                                /////////////////////////
        if(operations.size() > 0 ){
            shift.setOperations(operations);
           vector <Shift> shifts = solution.getShifts();
           shifts.push_back(shift);
           solution.setShifts(shifts);
        }

        timeWindows.erase(timeWindows.begin());
  /*      return recursiveRandomSolution(solution, time, horizonQuantities, tankQuantities, trailerQuantities,
                                       pastQuantities, lastOperations, timeWindows);
                                       */
      }

    return solution;
}
 
