//
//  Created by Federico Pagnozzi on 28/11/14.
//  Copyright (c) 2014 Federico Pagnozzi. All rights reserved.
//  This file is distributed under the BSD 2-Clause License. See LICENSE.TXT
//  for details.

#ifndef EMILIBASE_H
#define EMILIBASE_H


/** \mainpage EMILI
*<code>
*                                 ______ __  __ _____ _      _____   <br>
*                                |  ____|  \/  |_   _| |    |_   _|  <br>
*                                | |__  | \  / | | | | |      | |    <br>
*                                |  __| | |\/| | | | | |      | |    <br>
*                                | |____| |  | |_| |_| |____ _| |_   <br>
*                                |______|_|  |_|_____|______|_____|  <br>
*<br>
*</code>
*E.M.I.L.I. stands for Easily Modifiable (or Moddable) Iterated Local search Implementation.
*
*P.S.
*It's a very bad acronym but it's the best I could came up with in 5 minutes...
*
*In order to use this framework for running your things you should implement
*at least a problem specific extension of the classes Problem, Solution, InitialSolution,
*Neighborhood and, even though you could use the random move perturbation, Perturbation.
*/


#include <string>
#include <iostream>
#include <vector>

#ifndef NOC11
#include <random>
#else
//if the compiler does not support c++11 this compile path will be selected.
#include <tr1/random>
//#define nullptr NULL
const // It is a const object...
class nullptr_t
{
  public:
    template<class T>
    inline operator T*() const // convertible to any type of null non-member pointer...
    { return 0; }

    template<class C, class T>
    inline operator T C::*() const   // or any type of null member pointer...
    { return 0; }

   private:
    void operator&() const;  // Can't take address of nullptr

} nullptr = {};
#endif
#include <functional>


/**
 * emili enclose all the components of the EMILI framework.
 */
namespace emili{
/**
 * @brief iteration_counter_zero
 * reset the iterations counter
 */
void iteration_counter_zero();
/**
 * @brief iteration_counter
 * @return
 * returns iterations counter that is used in the neighborhoods to keep track of how many solutions are generated
 */
unsigned long iteration_counter();
/**
 * @brief iteration_increment
 * adds 1 to the iterations counter
 */
void iteration_increment();
/**
 * @brief iteration_decrement
 * subtracct 1 to the iterations counter
 */
void iteration_decrement();
/**
 * @brief set_print
 * sets the print flag for the system timer hook function (finalise).
 * @param p
 *   if true finalise will print the solution description otherwise it will print only
 *   the value of the iterations counter, the objective function value of the best solution and
 *   the running time.
 */
void set_print(bool p);
/**
 * @brief get_print
 *  Function to tell the system timer hook if it has to print solution info
 * @return
 *  true if the flag is set, false otherwise
 */
bool get_print();

/**
 * @brief initializeRandom
 * a consistent and centralized implementation of the random function that uses the marsenne twister.
 * This particular kind of random number generator, using the same random number,
 * returns always the same sequence ( that is guaranteed to not repeat itself up to a certain limit )
 * intialize the Marsenne twister with seed.
 * @param seed
 * the random seed.
 */
void initializeRandom(int seed);
#ifdef NOC11
std::tr1::mt19937& getRandomGenerator();
#else
/**
 * @brief getRandomGenerator
 * @return
 *     returns the Marsenne twister random generator
 */
std::mt19937& getRandomGenerator();
#endif
/**
 * @brief generateRandomNumber
 * @return
 * returns an integer generated by the centralized random number generator
 */
int generateRandomNumber();
/**
 * @brief generateRealRandomNumber
 * @return
 * returns a float generated by the centralized random number generator
 */
float generateRealRandomNumber();
/** TIME RELATED STUFF */
/**
 * @brief getCurrentExecutionTime
 * @return
 * this function returns the time from the beginning of the execution in seconds
 */
double getCurrentExecutionTime();

class Solution;
/**
 * @brief The Problem class
 * The istance of the problem to solve.
 */
class Problem{
public:     
    /**
     * @brief calcObjectiveFunctionValue
     * This function calculates the objective function value of solution and returns
     * it as a double.
     * @param solution
     * the solution to use in the calculation of the objective function value.
     * @return
     * a double representing the cost of solution
     */
    virtual double calcObjectiveFunctionValue(Solution& solution)=0;
    /**
     * @brief evaluateSolution
     *  This function calculates the objective function value and, using setSolutionValue,
     *  update the solution value in the Solution class.
     * @param solution
     * @return
     * the return value should be the objective function value of the solution
     */
    virtual double evaluateSolution(Solution & solution)=0;
    /**
     * @brief solutionDistance
     * In several problems, the objective function value of a solution can
     * be calculated more efficiently by calcuting the "distance" with another
     * solution. The default behaviour of this method is to return the difference
     * in objective function value, but it should be overwritten when the solution
     * representation and the problem type allow thi kind of speedup.
     * @param solution1
     * @param solution2
     * @return
     * the distance as a double
     */
    virtual double solutionDistance(Solution& solution1, Solution& solution2);
    /**
     * @brief problemSize
     * @return
     *  if overloaded this function should return the problem size as an integer number
     *  This value is used by some Termination criterion and by the -ro running option
     */    
    virtual int problemSize();
};

/**
 * @brief The Solution class
 * This class models a solution to an optimization problem.
 * I'm not sure if the fact that the solution must contain an instance
 * of the base class problem
 * is a good thing...
 */
class Solution
{
protected:
    /**
     * @brief solution_value
     *  the objective function value
     */
    double solution_value;
    /**
     * @brief getRawData
     * It's ugly I know, but every problem has its own data structures.
     * The next version will have an object designed to be a data carrier.
     * @return
     *  a pointer to the raw data which is the problem dependent data structures of the solution
     */
    virtual const void* getRawData()const=0;
    /**
     * @brief setRawData
     * changes the rawdata of the solution to data.
     *  The definition of the corresponding instance variable is not here because this variable
     *  can be defined, in the child class, as a pointer to the actual type of raw data
     *  so you can avoid the use of a pointer to void.
     * @param data
     */
    virtual void setRawData(const void* data)=0;
public:
    /**
     * @brief Solution
     * The constructor of Solution.
     * @param value
     */
    Solution(double value):solution_value(value)    {    }
    /**
     * @brief operator =
     * Copy operator, two Solution are equal if they have
     * the same solution_value and the same rawData. The function
     * use setRawData and getRawData to ensure that the rawData is
     * copied correctly
     * @param a
     * @return
     * The copied solution
     */
    virtual Solution& operator=(const Solution& a);    
    /**
     * @brief operator <
     * @param a
     * @return
     * returns solution_value < a.solution_value
     */
    virtual bool operator<(Solution& a);
    /**
     * @brief operator <=
     * @param a
     * @return
     * returns solution_value <= a.solution_value
     */
    virtual bool operator<=(Solution& a);
    /**
     * @brief operator >=
     * @param a
     * @return
     *  returns solution_value >= a.solution_value
     */
    virtual bool operator>=(Solution& a);
    /**
     * @brief operator >
     * @param a
     * @return
     *  returns solution_value > a.solution_value
     */
    virtual bool operator>(Solution& a);
    /**
     * @brief operator =
     * @param a
     * @return
     *  returns solution_value = a.solution_value
     */
    virtual bool operator==(Solution& a);
    /**
     * @brief getSolutionRepresentation
     * @return
     * returns an empty string. A child class should return a representation of
     * the solution. ( e.g. for permutation flowshop a permutaion ).
     */
    virtual std::string getSolutionRepresentation();
    /**
     * @brief getSolutionValue
     * @return
     *  returns the objective function value
     */
    virtual double getSolutionValue();
    /**
     * @brief setSolutionValue
     *  sets the objective function value
     * @param value
     */
    virtual void setSolutionValue(double value);
    /**
     * @brief clone
     * this method should return a pointer to a clone of the Solution.
     * The clone is expected to be allocated on the heap (so created with 'new').
     * @return
     * return a pointer to a clone of the Solution.
     */
    virtual Solution* clone()=0;
    /**
     *@brief isFeasible
     * This method should be overwritten if the problem has
     * unfeasible solutions.
     * this method should return true if the Solution is feasible and
     * false in the other case.
     */
    virtual bool isFeasible() {return true;}

    /**
     * @brief ~Solution
     * Destructor of Solution.
     * This method should always be overloaded and when called delete the raw data
     * (if allocated on the heap).
     */
    virtual ~Solution() {}
};

/**
 * @brief printSolstats
 *  Function to print solution info in the form "time, object function value, iteration"
 *
 * NOTE:
 * WITH_STATS must be defined when running cmake.
 * @param sol
 */
inline void printSolstats(emili::Solution* sol);

/**
 * @brief The InitialSolution class
 * The initial solution generator
 */
class InitialSolution
{
protected:
    /**
     * @brief instance
     * The problem instance
     */
    Problem& instance;
public:
    /**
     * @brief InitialSolution
     *  The constructor only needs the problem instance to build an initial solution
     * @param problem_instance
     */
    InitialSolution(Problem& problem_instance):instance(problem_instance){}
    /**
     * @brief generateSolution
     * The generated solution must be a valid solution for the problem with
     * the appropriate data structures used for the implemented solution.
     * @return
     *  A new solution for instance
     */
    virtual Solution* generateSolution()=0;
    /**
     * @brief generateEmptySolution
     * The method should generate an empty solution correctly allocated in
     * memory. This method is necessary because the LocalSearch class
     * and his extensions do not have any clou on how to allocate a solution.
     * @return
     * A solution object with all his data structures initialiazed
     */
    virtual Solution* generateEmptySolution()=0;
    /**
     * @brief getProblem
     *  returns the problem instance loaded at the beginning of the execution
     * @return
     *  the problem instance
     */
    virtual Problem& getProblem() {return instance;}
    /**
     * @brief ~InitialSolution
     * This method should be overloaded by the child class to delete
     *  anything it allocates on the heap
     */
    virtual ~InitialSolution() {}
};


/**
 * @brief The Termination class
 * Implements the concept of Termination Criterion.
 * Extends this to implement your termination criterion.
 */
class Termination
{
public:    
    /**
     * @brief terminate
     * the method called by emili::LocalSearch objects to know when terminate the execution
     * @param currentSolution
     * the best solution found so far
     * @param newSolution
     * the solution found in the last iteration of the search
     * @return
     * this method shall return true if the termination condition has been reached (otherwise false)
     */
    virtual bool terminate(Solution* currentSolution, Solution* newSolution)=0;
    /**
     * @brief reset
     * it should be possible to reset the state ( e.g. counters) of a Termination criterion.
     */
    virtual void reset()=0;
    virtual ~Termination() {}
};

/**
 * @brief The LocalMinimaTermination class
 * This termination criterion checks if newSolution improves on currentSolution,
 * if it does not improve the termination condition is verified and terminate returns true.
 */
class LocalMinimaTermination: public emili::Termination
{
public:
    /**
     * @brief LocalMinimaTermination
     *  Does not need anything
     */
    LocalMinimaTermination() {}
    /**
     * @brief terminate
     * @return
     * returns true if newSolution < currentSolution
     */
    virtual bool terminate(Solution* currentSolution, Solution* newSolution);
    /**
     * @brief reset
     *  nothign to reset. The decision to terminate depends only on the
     *  objective function value of the two solutions.
     */
    virtual void reset() { }
};

/**
 * @brief The WhileTrueTermination class
 * The equivalent of a while(true) in the search loop...
 * This termination should be always used with the system timer
 * termination ( the -it and -ro options ).
 */
class WhileTrueTermination: public Termination
{
public:
    /**
     * @brief terminate
     *  This termination criterion never triggers termination.
     * @return
     *  always false.
     */
    virtual bool terminate(Solution* currentSolution, Solution* newSolution);
    /**
     * @brief reset
     * nothing to reset.
     */
    virtual void reset() { }
};

/**
 * @brief The TimedTermination class
 * It checks if the timer is expired every time terminate it's called.
 * This timer does not depend on the -ro and -it options ( that's the system timer),
 * therefore this timer is not as precise but it can be used when the system timer
 * fails ( windows? )
 */
class TimedTermination: public Termination
{
protected:
    /**
     * @brief secs
     * Running time in seconds
     */
    float secs;
    /**
     * @brief _ratio
     * not used.
     */
    float _ratio;
    /**
     * @brief start
     * the start time of the computation.
     */
    clock_t start;
public:
    /**
     * @brief TimedTermination
     *  the ratio parameters is not used anymore so secs is set to this value
     *  every time reset is called.
     * @param ratio
     *  maximum running time
     */
    TimedTermination(float ratio):secs(-1),_ratio(ratio) { }
    TimedTermination():secs(-1),_ratio(1) { }
    /**
     * @brief terminate
     * checks if the time passed since the start of the computation is less
     * than secs
     * @return
     * false if the time passed is less than secs, true otherwise
     */
    virtual bool terminate(Solution *currentSolution, Solution *newSolution);
    /**
     * @brief reset
     * sets secs to ratio and resets start to the current time
     */
    virtual void reset();
};
/**
 * @brief The MaxStepsTermination class
 * As the name suggests after max_steps this Termination returns true.
 */
class MaxStepsTermination : public Termination
{
protected:
    /**
     * @brief max_steps_
     * max number of steps
     */
    int max_steps_;
    /**
     * @brief current_step
     * current number of steps
     */
    int current_step;
public:
    /**
     * @brief MaxStepsTermination
     * MaxStepsTermination constructor
     * @param max_steps
     * max number of steps.
     */
    MaxStepsTermination(int max_steps):max_steps_(max_steps), current_step(0){ }
    /**
     * @brief terminate
     * Increments current_step and check if it's bigger than max_steps_
     * @return
     * current_step < max_steps_
     */
    virtual bool terminate(Solution *currentSolution, Solution *newSolution);
    /**
     * @brief reset
     * resets current_step
     */
    virtual void reset();
};

/**
 * @brief The MaxStepsOrLocmin class
 * Triggers termination if the newSolution does not improve
 * or max number of steps is reached
 */
class MaxStepsOrLocmin : public emili::MaxStepsTermination
{
public:
    /**
     * @brief MaxStepsOrLocmin
     * MaxStepsOrLocmin
     * @param max_steps
     * max number of steps.
     */
    MaxStepsOrLocmin(int max_steps):emili::MaxStepsTermination(max_steps){ }
    /**
     * @brief terminate
     * Increments current_step and check if it's bigger than max_steps_
     * if current_step is not bigger than max_steps_ it checks if newsolution is
     * better than current solution.
     * @return
     */
    virtual bool terminate(Solution *currentSolution, Solution *newSolution);
};

/**
 * @brief The Neighborhood class
 *     The class models the neighborhood of a solution
 *     This class should return the neighbors of a base solution
 *     given a specific neighborhood relation.
 */
class Neighborhood
{
protected:
    /**
     * @brief computeStep
     * Takes step wich is a pointer to the base solution of the neighborhood
     * and applies the move.
     *
     * @return
     *  A solution representing the next neighbor
     */
    virtual Solution* computeStep(Solution* step)=0;
    /**
     * @brief reverseLastMove
     * Takes a solution and undoes the last move
     * @param step
     * the solution to change back
     */
    virtual void reverseLastMove(Solution* step)=0;
public:
    //unsigned long num();
        /**
        * @brief The NeighborhoodIterator class
        * This iterator shuold be used to iterate over the neighbors of
        * a base solution. It uses computeStep() and so it's compatible with
        * every extension of the Neighborhood Class
        */
       class NeighborhoodIterator : public std::iterator<std::forward_iterator_tag, emili::Solution> {
       public:
           /**
            * @brief NeighborhoodIterator
            * Iterator constructor
            * @param n
            * The Neighborhood to be used to generate the neighbors
            * @param startSolution
            * The base solution that is used to generate the neighbors
            */
           NeighborhoodIterator(emili::Neighborhood* n,emili::Solution* startSolution):base_(startSolution),n(n)
           {
               if(startSolution != nullptr )
               {
                  line_ = base_->clone();
                  base_value = base_->getSolutionValue();                  
                  emili::Solution* nline_ = n->computeStep(line_);
                  if(nline_ == nullptr)
                      delete line_;
                  line_ = nline_;
               }
               else
               {
                   line_=nullptr;
               }
           }
           /**
            * @brief operator =
            * Copy operator
            */
           NeighborhoodIterator& operator=(const NeighborhoodIterator& iter);
           /**
            * @brief operator ==
            * equal operator
            */
           bool operator==(const NeighborhoodIterator& iter);
           /**
            * @brief operator !=
            * inequality operator
            */
           bool operator != (const NeighborhoodIterator& iter);
           /**
            * @brief operator ++
            * increment operator
            * Using this operator makes the iterator pass to the next neighbor
            */
           NeighborhoodIterator& operator++();
           /**
            * @brief operator *
            * Using the reference operator returns a pointer to the
            * current neighbor.
            * @return
            * A pointer to the current neighbor
            */
           emili::Solution* operator*();           
       private:
           /**
            * @brief base_
            * base solution
            */
           emili::Solution* base_;
           /**
            * @brief base_value
            * base solution objective function value
            */
           double base_value;
           /**
            * @brief line_
            * current neighbor
            */
           emili::Solution* line_;
           /**
            * @brief n
            * Neighborhood relation used to generate the neighbors
            */
           emili::Neighborhood* n;
       };
       /**
        * @brief begin
        * Returns iterator pointing to the first neighbor
        * of base emili::Solution
        * @param base
        * base solution
        * @return
        * NeighborhoodIterator
        */
       virtual NeighborhoodIterator begin(emili::Solution* base);
       /**
        * @brief end
        * Returns iterator to the end of the neighborhood.
        * This iterator does not point to a valid solution but to nullptr.
        * @return
        * NeighborhoodIterator
        */
       virtual NeighborhoodIterator end();
    /** @brief step
     * this method returns a solution in the decided neighborhood
     * of the currentSolution */
    virtual Solution* step(Solution* currentSolution) { return computeStep(currentSolution);}
    /** @brief reset
     * The state of the Neighborhood object may need to be restored to
     * initial conditions between local search calls
     * (e.g. first improvement strategies for permutation flow shop).
     */
    virtual void reset()=0;
    /** @brief random
     * A method that returns a random solution in the neighborhood has to be provided.
     * This method shoudl return a new solution.
     */
    virtual Solution* random(Solution* currentSolution) = 0;
    /**
     * @brief random
     * When implementing metaheuristics like ILS or VNS it is usefull to
     * have a method that executes a random step in a given neighborhood of
     * a given size.
     * @param currentSolution
     * the base solution for the random step
     * @param size
     * the size of the step
     * @return
     * A new solution that is size-neighbor of currentSolution
     */
    virtual Solution* random(Solution *currentSolution, int size){return currentSolution;}

    /** @brief size
     * This method returns the size of the neighborhood
    */    
    virtual int size()=0;
    virtual ~Neighborhood() {}
};

/**
 * @brief The EmptyNeighBorHood class
 * This class models an empty neighborhood and used
 * together with EmptyLocalSearch and IteratedLocalSearch can be used to
 * instantiate a Simulated Annealing algorithm.
 */
class EmptyNeighBorHood: public emili::Neighborhood
{
protected:
    /** @brief computeStep
     * @return
     * nullptr
     */
    virtual Solution* computeStep(Solution *step) {return nullptr;}
    virtual void reverseLastMove(Solution *step) { }
public:
    EmptyNeighBorHood() {}
    /** @brief step
     * @return
     * the base solution
     */
    virtual Solution* step(Solution *currentSolution) {return currentSolution;}
    virtual void reset() { }
    /** @brief random
     * @return
     * the base solution
     */
    virtual Solution* random(Solution *currentSolution) { return currentSolution;}
    virtual int size() { return 0;}
};
/**
 * @brief The RandomConstructiveHeuristicNeighborhood class
 * A large neighborhood relation can be implemented
 * by Using this class with a random constructive heuristic
 * coded as an InitialSolution.
 */
class RandomConstructiveHeuristicNeighborhood: public emili::Neighborhood
{
protected:
    /**
     * @brief heuristic
     * The random constructive heuristic
     * used to explore the solution space
     */
    emili::InitialSolution* heuristic;
    /**
     * @brief state
     */
    int state;
    /**
     * @brief computeStep
     * At each invocation returns a solution
     * generated by the Heuristic.
     */
    virtual Solution* computeStep(Solution *step);
    /**
     * @brief reverseLastMove
     * Nothing to reverse.
     */
    virtual void reverseLastMove(Solution* step) {}
public:
    RandomConstructiveHeuristicNeighborhood(InitialSolution& init):heuristic(&init),state(0) {}
    /**
     * @brief random
     * At each invocation returns a solution
     * generated by the Heuristic.
     */
    virtual Solution* random(Solution *currentSolution) { return heuristic->generateSolution();}
    /**
     * @brief reset
     * There is nothing to reset.
     */
    virtual void reset(){ }
    /**
     * @brief size
     * This neighborhood does not have a proper size so
     * -1 is returned.
     */
    virtual int size(){ return -1; }
    virtual ~RandomConstructiveHeuristicNeighborhood() { delete heuristic;}
};

/** @brief The LocalSearch class
* This class models a very general local search.
*/
class LocalSearch
{
protected:
    /**
 * @brief init
 * the initial solution generator used to start the local search
 */
InitialSolution* init;
/**
 * @brief termcriterion
 * the Termination criterion of the Local Search
 */
Termination* termcriterion;
/**
 * @brief neighbh
 * The Neighborhood relation used by the Local Search
 */
Neighborhood* neighbh;
/**
 * @brief bestSoFar
 * the best solution found so far
 */
Solution* bestSoFar;
/**
 * @brief feasibleBest
 */
Solution* feasibleBest;
/**
 * @brief setBest
 * @param nBest
 */
inline void setBest(Solution* nBest);
/**
 * @brief seconds
 * Maximum amount of time, in seconds, for the local search
 */
float seconds;
/**
     * @brief LocalSearch
     * the empty constructor is declared protected so that an extending class can not
     * use a public one
     */
    LocalSearch():bestSoFar(nullptr),feasibleBest(nullptr) { }
public:
    /**
     * @brief LocalSearch
     * @param initialSolutionGenerator
     * the initial solution generator used to start the local search
     * @param terminationcriterion
     * the Termination criterion of the Local Search
     * @param neighborh
     * The Neighborhood relation used by the Local Search
     */
    LocalSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh):
    init(&initialSolutionGenerator),termcriterion(&terminationcriterion),neighbh(&neighborh),seconds(0),bestSoFar(initialSolutionGenerator.generateEmptySolution()),feasibleBest(nullptr)    {    }
    /**
     * @brief LocalSearch
     * @param initialSolutionGenerator
     * the initial solution generator used to start the local search
     * @param terminationcriterion
     * the Termination criterion of the Local Search
     * @param neighborh
     * The Neighborhood relation used by the Local Search
     * @param time
     * Maximum amount of time, in seconds, for the local search
     */
    LocalSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh, float time):
    init(&initialSolutionGenerator),termcriterion(&terminationcriterion),neighbh(&neighborh),seconds(time),bestSoFar(initialSolutionGenerator.generateEmptySolution()),feasibleBest(nullptr)    {    }
    /** @brief search
     * The method uses the InitialSolutionGenerator instance
     * to generate the first solution for the local search
    */
    virtual Solution* search();
    /** @brief search
     * a starting solution can be also provided
     */
    virtual Solution* search(Solution* initial);
    /** @brief timedSearch
     * this method ends the execution of the algorithm when the termination criterion is true or
     * after the amount of seconds provided as argument (regardless of the value of the termination).
     */
    virtual Solution* timedSearch(float seconds);
    /** @brief timedSearch
     * this method ends the execution of the algorithm when the termination criterion is true or
     * after the amount of seconds provided as argument (regardless of the value of the termination).
     */
    virtual Solution* timedSearch(float seconds, Solution* initial);
    /** @brief timedSearch
     * In order to make easier the creation of batchs of LocalSearch objects the time of execution
     * can be inserted as an instance variable in the constructor of the object so these methos below
     * rely on the value of that variable for the execution time.
     */
    virtual Solution* timedSearch();
    /** @brief timedSearch
     * this method ends the execution of the algorithm when the termination criterion is true or
     * after the amount of seconds provided as argument (regardless of the value of the termination).
     */
    virtual Solution* timedSearch(Solution* initial);
    virtual void setSearchTime(float time);
    virtual float getSearchTime();
    emili::Termination& getTermination();
    emili::Neighborhood& getNeighborhood();
    emili::InitialSolution& getInitialSolution();
    virtual Solution* getBestSoFar(); //{ return bestSoFar;}
    virtual void setBestSoFar(Solution* newBest);// {this->bestSoFar=newBest;}
    virtual ~LocalSearch();

};

/** @brief The EmptyLocalSearch class
 * This empty localsearch can be combined with ILS to
 * create a Simulated annealing
 */
class EmptyLocalSearch: public emili::LocalSearch
{
public:
    EmptyLocalSearch(InitialSolution& in):emili::LocalSearch() {
        this->init = &in;
        this->neighbh = new emili::EmptyNeighBorHood();
        this->termcriterion = new emili::MaxStepsTermination(0);
        this->bestSoFar = nullptr;
        }
    virtual Solution* search(Solution* initial) { return initial->clone();}
    virtual Solution* search();
    virtual Solution* timedSearch();
    virtual Solution* timedSearch(int seconds);
    virtual Solution* timedSearch(int seconds, Solution *initial) { return initial->clone();}
    virtual Solution* timedSearch(Solution* initial) {return initial->clone();}
    virtual Solution* getBestSoFar() { return nullptr;}
};
/*
 * @brief The FeasibleLocalSearch class
 * This local search takes into account infeasibility and
 * keeps two best solution feasible and unfeasible.
 * The feasible one is returned if it exisist at the end of its
 * execution.
 */
/*
class FeasibleLocalSearch: public emili::LocalSearch
{
protected:
    Solution* feasibleBest;
    inline void setBest(Solution* nBest);
public:
    FeasibleLocalSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh):emili::LocalSearch(initialSolutionGenerator,terminationcriterion,neighborh),feasibleBest(nullptr) { }
    virtual Solution* getBestSoFar();
    virtual void setBestSoFar(Solution* newBest);
};
*/
/** @brief The BestImprovementSearch class
 this class models a best improvement local search using the dumb neighborhood
 with the iterator interface.
 */
class BestImprovementSearch : public emili::LocalSearch
{
public:
    BestImprovementSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh):emili::LocalSearch(initialSolutionGenerator,terminationcriterion,neighborh) {}
    virtual Solution* search(emili::Solution* initial);   
};

/** @brief TieBraking BestImprovementSearch class
 this class models a best improvement local search with the iterator interface,
 that uses the objective function value of another problem to break ties between
 candidate solution with the same objective function value.
 */
class TieBrakingBestImprovementSearch : public emili::BestImprovementSearch
{
protected:
    Problem& tiebraker;
public:
    TieBrakingBestImprovementSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh, Problem& problem):emili::BestImprovementSearch(initialSolutionGenerator,terminationcriterion,neighborh),tiebraker(problem) {}
    virtual Solution* search(emili::Solution* initial);
};

/** @brief The FeasibleBestImprovementSearch class
 * this class models a best improvement local search with the iterator interface.
 */
class FeasibleBestImprovementSearch : public emili::LocalSearch
{
public:
    FeasibleBestImprovementSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh):emili::LocalSearch(initialSolutionGenerator,terminationcriterion,neighborh) {}
    virtual Solution* search(emili::Solution* initial);
};

/** @brief The FirstImprovementSearch class
 this class models a first improvement local search using the dumb neighborhood
 with the iterator interface.
 */
class FirstImprovementSearch : public emili::LocalSearch
{
public:
    FirstImprovementSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh):emili::LocalSearch(initialSolutionGenerator,terminationcriterion,neighborh) {}
    virtual Solution* search(emili::Solution* intial);
};

/** @brief The TieBraking FirstImprovementSearch class
 this class models a best improvement local search with the iterator interface,
 that uses the objective function value of another problem to break ties between
 candidate solution with the same objective function value.
 */
class TieBrakingFirstImprovementSearch : public emili::FirstImprovementSearch
{
protected:
    Problem& tiebraker;
public:
    TieBrakingFirstImprovementSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh, Problem& problem):emili::FirstImprovementSearch(initialSolutionGenerator,terminationcriterion,neighborh),tiebraker(problem) {}
    virtual Solution* search(emili::Solution* intial);
};

/** @brief The FeasibleFirstImprovementSearch class
 this class models a first improvement local search using the dumb neighborhood
 with the iterator interface.
 */
class FeasibleFirstImprovementSearch : public emili::LocalSearch
{
public:
    FeasibleFirstImprovementSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh):emili::LocalSearch(initialSolutionGenerator,terminationcriterion,neighborh) {}
    virtual Solution* search(emili::Solution* intial);
};

/** @brief The Perturbation class
* The pertubation phase of the ils.
*/
class Perturbation
{
  public:
    /**
     * @brief perturb
     * The method returns a perturbed solution generated starting from solution
     * @param solution
     * The solution to perturb
     * @return
     * A new solution representing the perturbed solution
     */
    virtual Solution* perturb(Solution* solution)=0;

    virtual ~Perturbation() { }
};

/** @brief The NoPerturbation class
 * NO pertubation
 */
class NoPerturbation: public emili::Perturbation
{
public:
    /**
     * @return
     * returns a clone of solution
     */
    virtual Solution* perturb(Solution *solution) { return solution->clone();}
};

/** @brief RandomMovePerturbation
    Performs a series of random steps in the given neighborhood.
*/
class RandomMovePerturbation : public emili::Perturbation
{
protected:
    /**
     * @brief explorer
     * The neighborhood relation used to generated the perturbed solution
     */
    Neighborhood& explorer;
    /**
     * @brief numberOfSteps
     * Number of steps to execute using the explorer Neighborhood
     */
    int numberOfSteps;
public:
    RandomMovePerturbation(Neighborhood& neighboorhod, int number_of_steps):explorer(neighboorhod),numberOfSteps(number_of_steps) { }
    /**
     * @brief perturb
     * The method takes solution and does numberOfSteps random
     * steps in the explorer Neighborhood.
     */
    virtual Solution* perturb(Solution* solution);
};
/**
 * @brief The VNRandomMovePerturbation class
 * Performs a series of random steps in the given neighborhoods.
 */
class VNRandomMovePerturbation : public emili::Perturbation
{
protected:
  std::vector< Neighborhood* > explorers;
  int numberOfSteps;
  int numberOfIterations;
  int currentIteration;
  int currentExplorer;
public:
  VNRandomMovePerturbation(std::vector< Neighborhood* > neighborhoods, int number_of_steps, int number_of_iterations):explorers(neighborhoods),numberOfSteps(number_of_steps),numberOfIterations(number_of_iterations),currentIteration(0),currentExplorer(0) { }
  virtual Solution* perturb(Solution *solution);
};
/**
 * @brief The RandomPerturbationSet class
 * Applies a perturbation selected randomly from a perturbations set
 * Can be used to instantiate a Large neighborhood search when used with ILS, nols, and
 * each perturbations is a destruct-construct operator.
 */
class RandomPerturbationSet : public emili::Perturbation
{
protected:
    std::vector<Perturbation*> perturbations;
    int size;
public:
    RandomPerturbationSet(std::vector< Perturbation* > perturbations):perturbations(perturbations),size(perturbations.size()) { }
    virtual Solution* perturb(Solution *solution);
    ~RandomPerturbationSet() {
        for(std::vector<Perturbation*>::iterator it = perturbations.begin();it!=perturbations.end();++it)
        {
            delete *it;
        }
     }
};

class ComplexPerturbation : public emili::Perturbation
{
protected:
    emili::Perturbation* p;
    emili::LocalSearch* ls;
public:
    ComplexPerturbation(emili::Perturbation* perturbation, emili::LocalSearch* localsearch):p(perturbation),ls(localsearch) { }
    virtual Solution* perturb(Solution *solution);
    ~ComplexPerturbation() {delete p; delete ls;}
};
/**
 * @brief The MRSILSPerturbation class
 * implements the multi restart perturbation scheme described
 * in DonCheHuaNow2013
 */
class MRSILSPerturbation : public emili::Perturbation
{
protected:
    emili::Perturbation* p;
    std::vector< emili::Solution* > solution_pool;
    int pool_size;
    int worst;
public:
    MRSILSPerturbation(emili::Perturbation* perturbation,int poolSize):
                       p(perturbation),
                       pool_size(poolSize),
                       worst(0)
    { }

    virtual Solution* perturb(Solution *solution);
    ~MRSILSPerturbation() {delete p;}

};

/**
 * @brief The Acceptance class
 */
class Acceptance
{
public:
    /** @brief accept
     *  the accept method decides the direction of the search by choosing between intensification and diversification,
     *  the IteratedLocalSearch class calls this method putting as first paramenter the solution used for pertubation
     *  in the last iteration and as second parameter the result of the local search around the pertubed solution.
    */
    virtual Solution* accept(Solution* intensification_solution,Solution* diversification_solution)=0;
    virtual void reset() { }
    virtual ~Acceptance() { }
};
/**
 * @brief The accept_candidates enum
 */
enum accept_candidates {ACC_INTENSIFICATION,ACC_DIVERSIFICATION};

class AlwaysAccept : public emili::Acceptance
{
protected:
    accept_candidates acc;
public:
    AlwaysAccept(accept_candidates choice):acc(choice) { }
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
};

class ImproveAccept : public emili::Acceptance
{
public:
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
};

class AcceptImproveEqual : public emili::Acceptance
{
public:
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
};

class AcceptPlateau : public emili::Acceptance
{
protected:
    int max_plateau_steps;
    int current_step;
    int threshold_status;
    int plateau_threshold;
public:
    AcceptPlateau(int maxNonImprovingSteps,int threshold):max_plateau_steps(maxNonImprovingSteps),plateau_threshold(threshold),current_step(0),threshold_status(0) { }
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
};
/**
 * @brief The AcceptExplore class
 * This acceptance criterion accepts always new solution for at least k
 * search steps, if no improvement is found after k steps it will make
 * the search go back to the best solution.
 */
class AcceptExplore : public emili::Acceptance
{
protected:
    int k;
    int iteration;
public:
    AcceptExplore(int steps):k(steps),iteration(0) {}
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
};

/**
 * IteratedLocalSearch it's a general implementation of iterated local search.
*/
class IteratedLocalSearch: public emili::LocalSearch
{
protected:
    LocalSearch& ls;
    Perturbation& pert;
    Acceptance& acc;

public:
    IteratedLocalSearch(LocalSearch& localsearch,Termination& terminationcriterion,Perturbation& perturb,Acceptance& accept):emili::LocalSearch(localsearch.getInitialSolution(),terminationcriterion,localsearch.getNeighborhood()),ls(localsearch),pert(perturb),acc(accept){}

    virtual Solution* search();
    virtual Solution* search(emili::Solution* initial);
    virtual Solution* timedSearch(float seconds);
    virtual Solution* timedSearch(float seconds,emili::Solution* initial);
    virtual Solution* getBestSoFar();
    virtual ~IteratedLocalSearch() {delete &pert; delete &acc;}
};

/**
 * IteratedLocalSearch it's a general implementation of iterated local search.
*/
class FeasibleIteratedLocalSearch: public emili::IteratedLocalSearch
{
public:
    FeasibleIteratedLocalSearch(LocalSearch& localsearch,Termination& terminationcriterion,Perturbation& perturb,Acceptance& accept):emili::IteratedLocalSearch(localsearch,terminationcriterion,perturb,accept){}

    virtual Solution* search();
    virtual Solution* search(emili::Solution* initial);
    virtual Solution* timedSearch(float seconds);
    virtual Solution* timedSearch(float seconds,emili::Solution* initial);
    virtual Solution* getBestSoFar();
    virtual ~FeasibleIteratedLocalSearch() {}
};

/**
    This class models the memory of a tabu search.
*/
class TabuMemory
{
protected:
    int tabutenure;
public:
    TabuMemory(int tenureSize):tabutenure(tenureSize) { }
    TabuMemory():tabutenure(1) { }
    /**
     * tabu_check determines if the input it's a forbidden solution.
     * this method should return true if the solution is not tabu and false in the other case,
     */
    virtual bool tabu_check(emili::Solution* solution) = 0;
    /**
     * this method should mark the input as a forbidden solution.
     */
    virtual void forbid(emili::Solution* solution) = 0;
    /**
     * TabuSearch calls this method to let the tabumemory elaborate and store
     * a step (or move).
     * It should be overwritten only if the kind of memory
     * to be implemented needs to know this information.
     */
    virtual void registerMove(emili::Solution* base,emili::Solution* solution) {}
    /**
     * resets the state of the memory.
     * To be used to restore the object state between two distinct search.
     */
    virtual void reset()=0;
    /**
     * Some tabu memory needs to work close with the neighborhood
     * to be able to register the move
     */
    virtual void setNeighborhood(emili::Neighborhood* neighborhood){return;}
    virtual void setTabuTenure(int tt) { this->tabutenure = tt; }

};

/** class TabuNeighborhood: public emili::Neighborhood
{
protected:
    int tabutenure;
public:
    TabuNeighborhood(int tt_size):tabutenure(tt_size) { }
};
*/
/**
  Tabu search implementation that uses the best improvement pivot rule
 */
class BestTabuSearch: public emili::LocalSearch
{
protected:
    emili::TabuMemory& tabuMemory;
public:
    BestTabuSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh,TabuMemory& tabut):
    emili::LocalSearch(initialSolutionGenerator,terminationcriterion,neighborh),tabuMemory(tabut)
    { tabuMemory.setNeighborhood(&neighborh);   }
    virtual emili::Solution* search(emili::Solution* initial);
    virtual emili::Solution* search();
};
/**
  Tabu search implementation that uses the first improvement pivot rule
 */
class FirstTabuSearch: public emili::BestTabuSearch
{
public:
    FirstTabuSearch(InitialSolution& initialSolutionGenerator ,Termination& terminationcriterion, Neighborhood& neighborh,TabuMemory& tabut):
    emili::BestTabuSearch(initialSolutionGenerator,terminationcriterion,neighborh,tabut) {    }
    virtual emili::Solution* search(emili::Solution* initial);
};


/**
 * Variable Neighborhood Descent implementation
 * accept as template parameters a LocalSearch and uses it with the various kinds of neighborhoods
 */

template <class T>
class VNDSearch: public T
{
protected:
    std::vector < emili::Neighborhood* > neigh;
public:
    VNDSearch(emili::InitialSolution& is, emili::Termination& tc, std::vector< emili::Neighborhood* > n):T(is,tc,*n[0]),neigh(n) { }
    VNDSearch(T& ls, std::vector<emili::Neighborhood*> n):T(ls),neigh(n) { }
    virtual emili::Solution* search(emili::Solution *initial)
    {

        this->neighbh = neigh[0];
        Solution* incumbent = T::search(initial);
        int i = 0;
        do{
            this->neighbh = neigh[i];
            Solution* new_s = T::search(incumbent);
            if(*new_s < *incumbent)
            {
                delete incumbent;
                incumbent = new_s;
                i = 0;
            }
            else
            {
        delete new_s;
                i = i+1;
            }
        }while(i < neigh.size());
        return incumbent;
    }
};

/**
 * Variable Neighborhood Descent implementation
 * accept as template parameters a LocalSearch and uses it with the various kinds of neighborhoods
 */


class LS_VND: public LocalSearch
{
protected:
    std::vector < emili::LocalSearch* > neigh;

public:
    LS_VND(emili::InitialSolution& is, emili::Termination& tc, std::vector< emili::LocalSearch* > n):LocalSearch(),neigh(n)
    {
        this->init = &is;
        this->termcriterion = &tc;
        this->bestSoFar = is.generateEmptySolution();
    }
    LS_VND(emili::LocalSearch& ls, std::vector<emili::LocalSearch*> n):LocalSearch(ls),neigh(n) { }
    virtual emili::Solution* search(emili::Solution *initial);
};

/**
 * @brief The Shake class models the shake operator of a VNS metaheuristics
 */
class Shake: public Perturbation
{
protected:
    int Kmax;
public:
    Shake(int Nmax):Kmax(Nmax) {}
    int getKmax(){return Kmax;}
    virtual Solution* shake(Solution* s, int n)=0;
    virtual Solution* perturb(Solution *solution);
};

/**
 * @brief The PerShake class is a "meta" shake operator that allows the use of
 * Perturbation classes as neighborhoods
 */
class PerShake: public Shake
{
protected:
    std::vector< Perturbation* > shakes;
public:
    PerShake(std::vector<Perturbation*> perturbations):shakes(perturbations),Shake(perturbations.size()) {}
    virtual Solution* shake(Solution *s, int n);
};

class NeighborhoodShake: public Shake
{
protected:
    int n_num;
    std::vector< Neighborhood* > shakes;    
public:
    NeighborhoodShake(std::vector<Neighborhood*> nes, int max_size):shakes(nes),n_num(nes.size()),Shake(nes.size()*max_size) { }
    virtual Solution* shake(Solution *s, int n);
};

/**
 * @brief The NeighborhoodChange class models the component of a VNS that
 * decides if accepting a solution and controls the change of the current neighborhood
 */
class NeighborhoodChange: public Acceptance
{
protected:
    int kmax;
public:
    virtual Solution* neighborhoodChange(Solution *intensification_solution,Solution* diversification_solution,int& k)=0;
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
    virtual void setKmax(int kmax){ this->kmax = kmax;}
};
/**
 * @brief The AccNeighborhoodChange class allows the use of acceptance criteria as neighborhood
 * change operators. The neighborhood index is reset if the acceptance accepts the current solution
 * otherwise if the best of the iteration is accepted the neigboorhood index is incremented
 */
class AccNeighborhoodChange: public NeighborhoodChange
{
protected:
    Acceptance* acc;
public:
    AccNeighborhoodChange(Acceptance* acceptance):acc(acceptance) { }
    virtual Solution* neighborhoodChange(Solution *intensification_solution,Solution* diversification_solution,int& n);
};
/**
 * @brief The GVNS class
 * General Variable Neighborhood Search implementation
 */
class GVNS: public emili::LocalSearch
{
protected:
    emili::Shake& shaker;
    emili::NeighborhoodChange& changer;
    emili::LocalSearch& ls;
public:
    GVNS(emili::LocalSearch& localsearch,emili::Termination& term,emili::Shake& shake, emili::NeighborhoodChange& nchange):emili::LocalSearch(),ls(localsearch),shaker(shake),changer(nchange)
    {
        this->init = &ls.getInitialSolution();
        this->neighbh = new emili::EmptyNeighBorHood();
        this->termcriterion = &term;
        this->bestSoFar = init->generateEmptySolution();
    }
    virtual Solution* search(emili::Solution* initial);
    virtual Solution* getBestSoFar();
    virtual ~GVNS() {delete &shaker;delete &changer;}
};



/** DEPRECATED*/
class PipeSearch: public emili::LocalSearch
{
protected:
    std::vector <emili::LocalSearch*> lss;
public:
    PipeSearch(InitialSolution& is,std::vector< emili::LocalSearch*> lss):emili::LocalSearch(is,lss[0]->getTermination(),lss[0]->getNeighborhood()),lss(lss) { }
    virtual Solution* search(Solution* initial);
};

/**
 * Metropolis acceptance criterion implementation (fixed temperature)
 */
class MetropolisAcceptance: public emili::Acceptance
{
protected:
    float temperature;
public:
    MetropolisAcceptance(float startTemp):temperature(startTemp) { }
    void setTemp(float temp);
    float getTemp();
    virtual Solution* accept(Solution* intensification_solution,Solution* diversification_solution);
};
/**
 * Proper Metropolis acceptance criterion
 */
class Metropolis: public emili::Acceptance
{
protected:
    float temperature;
    float start_temp;
    float end_temp;
    int interval;
    int counter;
    float beta;
    float alpha;
public:
    Metropolis(float initial_temperature,float final_temperature,float descending_ratio):temperature(initial_temperature),start_temp(initial_temperature),end_temp(final_temperature),beta(descending_ratio),interval(1),counter(0),alpha(1) { }
    Metropolis(float initial_temperature,float final_temperature,float descending_ratio,int iterations):temperature(initial_temperature),start_temp(initial_temperature),end_temp(final_temperature),beta(descending_ratio),interval(iterations),counter(0),alpha(1) { }
    Metropolis(float initial_temperature, float final_temperature, float descending_ratio, int iterations, float alpha):temperature(initial_temperature),start_temp(initial_temperature),end_temp(final_temperature),beta(descending_ratio),interval(iterations),counter(0),alpha(alpha) { }
    virtual Solution* accept(Solution *intensification_solution, Solution *diversification_solution);
    virtual void reset();
};

class ComposedInitialSolution: public emili::InitialSolution
{
protected:
    InitialSolution& is;
    LocalSearch& ls;
public:
    ComposedInitialSolution(InitialSolution& initial, LocalSearch& local):InitialSolution(initial.getProblem()),is(initial),ls(local){}
    virtual Solution* generateEmptySolution();
    virtual Solution* generateSolution();
    virtual ~ComposedInitialSolution() { delete &is; delete &ls;}
};

class AlternateLocalSearch: public emili::LocalSearch
{
protected:
    emili::LocalSearch* ls1;
    emili::LocalSearch* ls2;
    bool turn;
public:
    AlternateLocalSearch(InitialSolution& is,emili::LocalSearch* localsearch1, emili::LocalSearch* localsearch2 ):
        emili::LocalSearch(),
        ls1(localsearch1),
        ls2(localsearch2)
    {
        this->init = &is;
        this->neighbh = new EmptyNeighBorHood();
        this->termcriterion = new LocalMinimaTermination();
        turn = true;
    }

    emili::Solution* search(emili::Solution* );
    emili::Solution* getBestSoFar();

};

class MaxStepsNoImprov : public Termination
{
protected:
    int h;
    int max_h;
public:
    MaxStepsNoImprov(int max_steps):
        emili::Termination(),
        max_h(max_steps) { }

    bool terminate(Solution *currentSolution, Solution *newSolution);
    void reset();
};

/**
class SimulatedAnnealing : public emili::LocalSearch
{
protected:
emili::Acceptance* acceptance;
public:
SimulatedAnnealing(InitialSolution* initial,Neighborhood* neigh,Termination* term,Acceptance* acc):emili::LocalSearch(*initial,*term,*neigh),acceptance(acc) { }
virtual Solution* getBestSoFar();
virtual Solution* search(Solution *initial);
virtual ~SimulatedAnnealing() { delete acceptance;}
};
*/

/**  Kind of a reflection thing...*/
emili::LocalSearch* getAlgo();
void setRootAlgorithm(emili::LocalSearch* ls);
}
#endif // EMILIBASE_H
