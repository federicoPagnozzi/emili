


/*
    The class models a neighborhood of a solution

*/
class irpTwoExchangeNeighborhood : public emili::Neighborhood
{
protected:
    InventoryRoutingProblem irp;
    Solution * currentNeighboringSolution;
    int operation1;
    int operation2;
    int numberOfOperations1;
    int numberOfOperations2;
    int numberFeasibleSolutions; //in a neighborhood
    double bestValueFound;
    int pointInitialValue;
    unsigned int pointStep;
    virtual Solution* computeStep(Solution* step);
    virtual void reverseLastMove(Solution* step);
public:

     /*
      * Initialize shift and operation size, 4 indexes
      * this method needs to be overidden if there are things that a neighborhood has to do or reset when begin is called*/
     virtual NeighborhoodIterator begin(emili::Solution* base);

    /*this method returns a solution in the decided neighborhood
     * of the currentSolution */
    virtual Solution* step(Solution* currentSolution);
    /*
     * The state of the Neighborhood object may need to be restored to
     * initial conditions between local search calls
     * (e.g. first improvement strategies for permutation flow shop).
     */
    virtual void reset();
    /*
     * A method that returns a random solution in the neighborhood has to be provided
     */
    virtual Solution* random(Solution* currentSolution);
    /*
     * This method returns the size of the neighborhood
    */
    virtual int size();

    irpTwoExchangeNeighborhood(InventoryRoutingProblem &i, unsigned int piv, unsigned int ps):irp(i),numberFeasibleSolutions(0),bestValueFound(DBL_MAX),pointInitialValue(piv),pointStep(ps){}
};


///////////////////////////////////////////




emili::Neighborhood::NeighborhoodIterator emili::irp::irpTwoExchangeNeighborhood::begin(emili::Solution *startSolution)
{

    this->currentNeighboringSolution = startSolution->clone();
    InventoryRoutingSolution *irpStartSolution = dynamic_cast<InventoryRoutingSolution *> (startSolution);

    irpStartSolution->getIrpSolution().fromSolutionToRepresentation(irpStartSolution->getIrpSolution());
    unsigned int representationSize = irpStartSolution->getIrpSolution().getRepresentation().size();

    this->operation1 = 0;//(unsigned int) representationSize * (1.0/(double)this->pointInitialValue);
    this->operation2 = this->operation1;


    irp.evaluateSolution(*irpStartSolution);
//    irp.getIrpInstance().computeObjectiveShift(irpStartSolution->getIrpSolution());


    this->numberOfOperations1 = representationSize;
    this->numberOfOperations2 = representationSize;

    if(this->bestValueFound >= DBL_MAX - EPSILON){
        this->bestValueFound = irpStartSolution->getSolutionValue();
        this->numberFeasibleSolutions++;
  /*       string filepath;
         filepath.append("./Neighborhood/");
         filepath.append(this->irp.getIrpInstance().getName());filepath.append("/");
         filepath.append(to_string(this->numberFeasibleSolutions));
         filepath.append("NeighSolution.xml");
         irpStartSolution->getIrpSolution().saveSolution(filepath);*/
    }
//    COUT.clear();
    COUT<<"\nINITIAL BEGIN: "<<this->numberOfOperations1<<" "<<this->numberOfOperations2;

//    std::COUT.setstate(std::ios_base::failbit);
//        int a;CIN>>a;
    return emili::Neighborhood::NeighborhoodIterator(this,startSolution);

}



emili::Solution* emili::irp::irpTwoExchangeNeighborhood::step(Solution* currentSolution){

    return this->computeStep(currentSolution);
}

emili::Solution* emili::irp::irpTwoExchangeNeighborhood::computeStep(Solution* currentSolution){

    emili::iteration_increment();

    InventoryRoutingSolution *neighboringSolution = dynamic_cast<InventoryRoutingSolution *> (currentSolution);

//    this->irp.evaluateSolution(*neighboringSolution);

//    this->currentNeighboringSolution = dynamic_cast<Solution *> (neighboringSolution);


    if(this->operation2 < this->numberOfOperations2 - this->pointStep - 2){
        this->operation2+=this->pointStep;
        this->operation1 = this->operation2+1;
    }
  /*  else if(this->operation1 < this->numberOfOperations1 - 1){
        this->operation1++;
        this->operation2 = operation1+1;
        COUT<<this->operation1<<" "<<this->operation2<<"\n";
    }*/
    else
        return nullptr;

    int o1 = this->operation1;
    int o2 = this->operation2;
    unsigned int point1 = neighboringSolution->getIrpSolution().getRepresentation()[o1];
    unsigned int point2 = neighboringSolution->getIrpSolution().getRepresentation()[o2];

       COUT<<"\nEXCHANGE: "<<o1<<" "<<o2<<"   "<<point1<<" "<<point2<<"";
   //     this->irp.evaluateSolution(*neighboringSolution);
        vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
        representation[o1] = point2;
        representation[o2] = point1;
        irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, 0.0, 0.0, false);
        irps = irp.getIrpInstance().extendSolution(irps, 1.0, 0.0, 0, INT_MAX);
        irps.fromSolutionToRepresentation(irps);
        InventoryRoutingSolution irs(irps);
        cout<<"DELTA: "<<this->irp.getIrpInstance().computeDeltaObjective(neighboringSolution->getIrpSolution(),neighboringSolution->getIrpSolution(), 0)<<"\n";
        this->irp.evaluateSolution(irs);

        this->numberOfOperations1 = irs.getIrpSolution().getRepresentation().size();
        this->numberOfOperations2 = irs.getIrpSolution().getRepresentation().size();

        cout<<irs.getSolutionRepresentation();
        COUT<<"     OLD VALUE: "<<neighboringSolution->getSolutionValue();
        COUT<<"     NEW VALUE: "<<irs.getSolutionValue();

        if(irp.getIrpInstance().checkFeasibility(irs.getIrpSolution(), false))
            ;
        else if(irs.getSolutionValue() < this->bestValueFound){
            this->numberFeasibleSolutions++;
            this->bestValueFound = irs.getSolutionValue();
            string filepath;

           filepath.append("./Neighborhood/");
           filepath.append(this->irp.getIrpInstance().getName());filepath.append("/");
           filepath.append(to_string(this->numberFeasibleSolutions));
           filepath.append("NeighSolution.xml");
           irs.getIrpSolution().saveSolution(filepath);

           ofstream file;
           string filepath2;
           filepath2.append("./Neighborhood/");
           filepath2.append(this->irp.getIrpInstance().getName());
           filepath2.append("/Objective");
           file.open (filepath2,fstream::app);
           file.precision(15);
           file << this->bestValueFound << " "<<emili::iteration_counter()<<" "<< this->numberFeasibleSolutions << std::endl;
           file.close();


           COUT<<"A BEST FOUND: "<<this->bestValueFound<<"\n";
           COUT<<irs.getSolutionRepresentation()<<" \n\n";
        }
        else
            this->numberFeasibleSolutions++;

int a;cin>>a;

    /*
    * QUI COPIA lo stato interno di irs in currentSolution
    * neighboringSolution e currentSolution puntano allo stesso oggetto
    */

    *neighboringSolution = irs;
    return dynamic_cast<Solution *> (currentSolution);

}


void emili::irp::irpTwoExchangeNeighborhood::reset(){

    this->operation1 = this->pointInitialValue;
    this->operation2 = this->pointInitialValue;
    this->numberOfOperations1 = this->pointInitialValue;
    this->numberOfOperations2 = this->pointInitialValue;
//    this->numberFeasibleSolutions = 0;
}

emili::Solution* emili::irp::irpTwoExchangeNeighborhood::random(Solution* currentSolution){

        COUT<<"\nTOWEXC RANDOM\n";
        //int a;CIN>>a;
    InventoryRoutingSolution *neighboringSolution = new InventoryRoutingSolution(*dynamic_cast<InventoryRoutingSolution *> (currentSolution));
    InventoryRoutingSolution *irs;
    irpSolution irps = neighboringSolution->getIrpSolution();
    irps.fromSolutionToRepresentation(irps);
    neighboringSolution = new InventoryRoutingSolution(irps);
    this->irp.evaluateSolution(*neighboringSolution);
    this->operation1 = this->pointInitialValue;
    this->operation2 = this->pointInitialValue;
    this->numberOfOperations1 = neighboringSolution->getIrpSolution().getRepresentation().size();
    this->numberOfOperations2 = neighboringSolution->getIrpSolution().getRepresentation().size();

    int o1 = generateRandomNumber() % this->numberOfOperations1;
    int o2 = o1 + 1;/*generateRandomNumber() % this->numberOfOperations2;*/

    if(o2 >= this->numberOfOperations2){
        o2--;
        o1--;
    }


    unsigned int point1 = neighboringSolution->getIrpSolution().getRepresentation()[o1]/*neighboringSolution->getSolutionRepresentation()[o1]*/;
    unsigned int point2 = neighboringSolution->getIrpSolution().getRepresentation()[o2]/*neighboringSolution->getSolutionRepresentation()[o2]*/;
//    COUT<<neighboringSolution->getSolutionRepresentation();
    COUT<<"\n"<<o1<<" "<<o2<<"    "<<point1<<" "<<point2<<"\n";

    COUT<<"BEFORE EXCHANGE VALUE: "<<neighboringSolution->getSolutionValue()<<"\n";
//    for(int i=0; i<neighboringSolution->getSolutionRepresentation().size(); i++)
//        COUT<<neighboringSolution->getSolutionRepresentation()[i]<<" ";

//    if(  not(  (o1==o2) or (point1==point2)  )  ){

//        neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
        vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
        representation[o1] = point2;
        representation[o2] = point1;

        irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, 0.0, 0.0, false);
        irs = new InventoryRoutingSolution(irps);
        irs->getIrpSolution().fromSolutionToRepresentation(irs->getIrpSolution());
        this->irp.evaluateSolution(*irs);
        COUT<<" nEXC VALUE: "<<irs->getSolutionValue();

//    }

    return dynamic_cast<Solution *> (irs);
}

void emili::irp::irpTwoExchangeNeighborhood::reverseLastMove(Solution * step){

//    COUT<<"////////";
//    COUT<<"\nTWO EXC RATIO: "<<this->operation1<<" "<<this->operation2;

    /// //assegna un nuovo puntatore
//    step = this->currentNeighboringSolution;

    ///fa una copia
    *step = *currentNeighboringSolution;
    this->irp.evaluateSolution(*step);

//    COUT<<step->getSolutionRepresentation();
//    COUT<<"\nREVERSE VALUE: "<<step->getSolutionValue();
//   COUT<<"///////\n\n\n\n\n";
}

int emili::irp::irpTwoExchangeNeighborhood::size()
{
    return 1;
}
