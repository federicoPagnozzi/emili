#include "irp.h"

#define FEASIBILITY_PENALTY 10
#define POINT_INITIAL_VALUE 0
#define REFUEL_INITIAL_VALUE 0.0
#define REFUEL_STEP 0.1

const void* emili::irp::InventoryRoutingSolution::getRawData()const{

    return (void *) &this->irps;
}

void emili::irp::InventoryRoutingSolution::setRawData(const void* data){
    irpSolution *irps = (irpSolution *)data;
    this->irps = *irps;
}

std::string emili::irp::InventoryRoutingSolution::getSolutionRepresentation(){

    std::ostringstream repr;
    repr<<"\nSOLUTION REPRESENTATION: ";
    for(int s=0; s<this->irps.getShifts().size(); s++)
        for(int o=0; o<this->irps.getShifts()[s].getOperations().size(); o++)
            repr <<this->irps.getShifts()[s].getOperations()[o].getPoint()<<" ";
    repr<<"\n";
    return repr.str();
}

emili::irp::InventoryRoutingProblem::InventoryRoutingProblem(char* instance_path){

   irpInstance.loadInstance(instance_path);
}


double emili::irp::InventoryRoutingProblem::evaluateSolution(Solution & solution){

   InventoryRoutingSolution& s = dynamic_cast<InventoryRoutingSolution&> (solution);
   double p = this->irpInstance.computeObjective(s.getIrpSolution());
   if(this->irpInstance.checkFeasibility(s.getIrpSolution())){
       p *= FEASIBILITY_PENALTY;
  //     cout<<"NOT FEASIBLE! "<<p<<"\n";
   }
   else{
  //     cout<<"\n\nFEASIBLE!!!\n\n";
//       cout<<s.getSolutionRepresentation();
   }
   solution.setSolutionValue(p);
   return p;

}

Instance emili::irp::InventoryRoutingProblem::getIrpInstance(){
    return irpInstance;
}

emili::Solution* emili::irp::GreedyInitialSolution::generateSolution(){

    InventoryRoutingProblem& irp = dynamic_cast<InventoryRoutingProblem&> (this->instance);
    irpSolution irps;
    InventoryRoutingSolution *irs;
    unsigned int feasibleOriginalCounter = 0;
    for(double tw=0.0; tw<=1.0; tw+=0.02){
        for(double qw=0.0; qw<=1.0; qw+=0.02){

            irps = irp.getIrpInstance().backTrackingRandomSolution(tw, qw);
        //    irpSolution irps = irp.getIrpInstance().GreedySolution();

            irs = new InventoryRoutingSolution(irps);

            if(irp.getIrpInstance().checkFeasibility(irs->getIrpSolution())){
                cout<<"\nORIGINAL NOT FEASIBLE!\n";
        //        irs->getIrpSolution().saveSolution("OriginalSolution.xml");
            }
            else{
                cout<<"\nORIGINAL FEASIBLE!\n";
                string filepath;
                filepath.append("./Neighborhood/");
                filepath.append(to_string(feasibleOriginalCounter));
                filepath.append("OriginalSolution.xml");
                irs->getIrpSolution().saveSolution(filepath);
                feasibleOriginalCounter++;
                instance.evaluateSolution(*irs);
                cout<<"\nORIGINAL OBJ VALUE: "<<irs->getSolutionValue()<<"\n";
//                int a;cin>>a;
            }
        }
    }


//    irp.getIrpInstance().compute(irs->getIrpSolution());
    vector<unsigned int> representation;

    irs->getIrpSolution().fromSolutionToRepresentation(irs->getIrpSolution());
    irpSolution rebuiltSolution = irp.getIrpInstance().rebuildSolution(irs->getIrpSolution(),irs->getIrpSolution().getRepresentation(), 0.0, 0.0);
    if(irp.getIrpInstance().checkFeasibility(rebuiltSolution)){
        cout<<"\nRECOSTRUCTION NOT FEASIBLE!\n";
    }
    else{
        cout<<"\nRECOSTRUCTION FEASIBLE!\n";
        rebuiltSolution.saveSolution(*new string("RebuiltSolution.xml"));
    }

    instance.evaluateSolution(*irs);
    irs->getIrpSolution().fromSolutionToRepresentation(irs->getIrpSolution());
    cout<<"\n\nINITIAL OBJ VALUE: "<<irs->getSolutionValue()<<"\n\n";
    int a; cin>>a;

    return irs;

}

emili::Solution* emili::irp::InventoryRoutingSolution::clone(){

    InventoryRoutingSolution *irs = new InventoryRoutingSolution(this->irps);
    irs->setSolutionValue(this->solution_value);
    return irs;
}


irpSolution & emili::irp::InventoryRoutingSolution::getIrpSolution(){
    return this->irps;
}

emili::Solution* emili::irp::GreedyInitialSolution::generateEmptySolution(){

    return new InventoryRoutingSolution(DBL_MAX);
}

emili::Neighborhood::NeighborhoodIterator emili::irp::irpTwoExchangeNeighborhood::begin(emili::Solution *startSolution)
{
    InventoryRoutingSolution *irpStartSolution = dynamic_cast<InventoryRoutingSolution *> (startSolution);

    this->operation1 = POINT_INITIAL_VALUE;
    this->operation2 = POINT_INITIAL_VALUE;

    irpStartSolution->getIrpSolution().fromSolutionToRepresentation(irpStartSolution->getIrpSolution());
    irp.evaluateSolution(*irpStartSolution);

    this->numberOfOperations1 = irpStartSolution->getIrpSolution().getRepresentation().size()/*irpStartSolution->getIrpSolution().getShifts()[this->shift1].getOperations().size()*/;
    this->numberOfOperations2 = irpStartSolution->getIrpSolution().getRepresentation().size()/*irpStartSolution->getIrpSolution().getShifts()[this->shift2].getOperations().size()*/;
    this->numberFeasibleSolutions = 0;
    cout<<"INITIAL BEGIN: "<<this->numberOfOperations1<<" "<<this->numberOfOperations2<<"\n";
        int a;cin>>a;
    return emili::Neighborhood::NeighborhoodIterator(this,startSolution);

}



emili::Solution* emili::irp::irpTwoExchangeNeighborhood::step(Solution* currentSolution){

    return this->computeStep(currentSolution);
}

emili::Solution* emili::irp::irpTwoExchangeNeighborhood::computeStep(Solution* currentSolution){

    InventoryRoutingSolution *neighboringSolution = dynamic_cast<InventoryRoutingSolution *> (currentSolution);
    InventoryRoutingSolution *irs;

//    cout<<"INITIAL: "<<this->numberOfShifts1<<" "<<this->numberOfOperations1<<" "<<this->numberOfShifts2<<" "<<this->numberOfOperations2<<"\n";

    if(this->operation2 < this->numberOfOperations2 - 1){
        this->operation2++;
    }
    else if(this->operation1 < this->numberOfOperations1 - 1){
        this->operation1++;
        this->operation2 = operation1;
        cout<<this->operation1<<" "<<this->operation2<<"\n";
    }
    else
        return nullptr;

    int o1 = this->operation1;
    int o2 = this->operation2;
    unsigned int point1 = neighboringSolution->getIrpSolution().getRepresentation()[o1];
    unsigned int point2 = neighboringSolution->getIrpSolution().getRepresentation()[o2];
//    if(  not(  (o1==o2) or (point1==point2)    )  ){
        cout<<"\n\nEXCHANGE: "<<o1<<" "<<o2<<" "<<point1<<" "<<point2<<" "<<this->numberOfOperations1<<" "<<this->numberOfOperations2<<"\n\n";
//           cin>>o2;

        neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
        vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
        cout<<"REPRESENTATION SIZE: "<<representation.size()<<"\n\n";
        representation[o1] = point2;
        representation[o2] = point1;
        irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, 0.0, 0.0);
        irps.fromSolutionToRepresentation(irps);
        irs = new InventoryRoutingSolution(irps);


        this->numberOfOperations1 = irs->getIrpSolution().getRepresentation().size()/*irpStartSolution->getIrpSolution().getShifts()[this->shift1].getOperations().size()*/;
        this->numberOfOperations2 = irs->getIrpSolution().getRepresentation().size()/*irpStartSolution->getIrpSolution().getShifts()[this->shift2].getOperations().size()*/;

        irp.evaluateSolution(*irs);

        cout<<"\n\nVALUE: "<<irs->getSolutionValue()<<"\n\n";
//        int a; cin>>a;
        if(irp.getIrpInstance().checkFeasibility(irs->getIrpSolution()))
            cout<<"\nNEIGH NOT FEASIBLE!\n";
        else{
            cout<<"\nNEIGH FEASIBLE!\n";
            this->numberFeasibleSolutions++;
            string filepath;
            filepath.append("./Neighborhood/");
            filepath.append(to_string(this->numberFeasibleSolutions));
            filepath.append("NeighSolution.xml");
            irs->getIrpSolution().saveSolution(filepath);
        }
//    }

    return dynamic_cast<Solution *> (irs);

}


void emili::irp::irpTwoExchangeNeighborhood::reset(){

    this->operation1 = POINT_INITIAL_VALUE;
    this->operation2 = POINT_INITIAL_VALUE;
    this->numberOfOperations1 = POINT_INITIAL_VALUE;
    this->numberOfOperations2 = POINT_INITIAL_VALUE;
    this->numberFeasibleSolutions = 0;
}

emili::Solution* emili::irp::irpTwoExchangeNeighborhood::random(Solution* currentSolution){

    InventoryRoutingSolution *neighboringSolution = new InventoryRoutingSolution(*dynamic_cast<InventoryRoutingSolution *> (currentSolution));
    InventoryRoutingSolution *irs;

    int o1 = generateRandomNumber() % this->numberOfOperations1;
    int o2 = generateRandomNumber() % this->numberOfOperations2;

    unsigned int point1 = neighboringSolution->getSolutionRepresentation()[o1];
    unsigned int point2 = neighboringSolution->getSolutionRepresentation()[o1];
    if(  not(  (o1==o2) or (point1==point2)  )  ){

        neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
        vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
        representation[o1] = point2;
        representation[o2] = point1;
        irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, 0.0, 0.0);
        InventoryRoutingSolution *irs = new InventoryRoutingSolution(irps);
        irs->getIrpSolution().fromSolutionToRepresentation(irs->getIrpSolution());

    }
    return dynamic_cast<Solution *> (irs);
}

void emili::irp::irpTwoExchangeNeighborhood::reverseLastMove(Solution * step){

    //invert last operation: apply move without updating indexes

    int o1 = this->operation1;
    int o2 = this->operation2;
    InventoryRoutingSolution *neighboringSolution = dynamic_cast<InventoryRoutingSolution *> (step);
    unsigned int point1 = neighboringSolution->getIrpSolution().getRepresentation()[o1]/*neighboringSolution->getIrpSolution().getShifts()[s1].getOperations()[o1].getPoint()*/;
    unsigned int point2 = neighboringSolution->getIrpSolution().getRepresentation()[o2]/*neighboringSolution->getIrpSolution().getShifts()[s2].getOperations()[o2].getPoint()*/;
    if(  not(  (o1==o2) or (point1==point2)  )  ){

        neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
        vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
        unsigned int app = representation[o1];
        representation[o1] = representation[o2];
        representation[o2] = app;
        irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, 0.0, 1.0);
        InventoryRoutingSolution *irs = new InventoryRoutingSolution(irps);

//        this->numberFeasibleSolutions--;
    }

}

int emili::irp::irpTwoExchangeNeighborhood::size()
{
    return 1;
}


emili::Neighborhood::NeighborhoodIterator emili::irp::irpRefuelNeighborhood::begin(emili::Solution *startSolution)
{
    InventoryRoutingSolution *irpStartSolution = dynamic_cast<InventoryRoutingSolution *> (startSolution);
    this->refuelRatio = REFUEL_INITIAL_VALUE;
    this->refuelStep = REFUEL_STEP;
    this->deliveredQuantityRatio = /*REFUEL_INITIAL_VALUE*/-REFUEL_STEP;
    this->deliveredQuantityStep = REFUEL_STEP;
    this->numberFeasibleSolutions = 0;

    irpStartSolution->getIrpSolution().fromSolutionToRepresentation(irpStartSolution->getIrpSolution());
    irp.evaluateSolution(*irpStartSolution);

    cout<<"BEGIN INITIAL: "<<this->refuelRatio<<" "<<this->refuelStep<<" \n";
    return emili::Neighborhood::NeighborhoodIterator(this,startSolution);

}


emili::Solution* emili::irp::irpRefuelNeighborhood::step(Solution* currentSolution){

    return this->computeStep(currentSolution);
}

emili::Solution* emili::irp::irpRefuelNeighborhood::computeStep(Solution* currentSolution){

    InventoryRoutingSolution *neighboringSolution = dynamic_cast<InventoryRoutingSolution *> (currentSolution);
    InventoryRoutingSolution *irs;

    if(this->deliveredQuantityRatio <= 1.0-this->deliveredQuantityStep and this->refuelRatio <= 1.0){
        this->deliveredQuantityRatio += this->deliveredQuantityStep;
    }
    else if(this->refuelRatio <= 1.0-this->refuelStep){
        this->deliveredQuantityRatio = REFUEL_INITIAL_VALUE;
        this->refuelRatio += this->refuelStep;
    }
    else
        return nullptr;

    if(this->deliveredQuantityRatio <= 1.0-this->deliveredQuantityStep and this->refuelRatio <= 1.0){
        this->deliveredQuantityRatio += this->deliveredQuantityStep;
    }
    else if(this->refuelRatio <= 1.0-this->refuelStep){
        this->deliveredQuantityRatio = REFUEL_INITIAL_VALUE;
        this->refuelRatio += this->refuelStep;
    }
    else
        return nullptr;

    cout<<"\nPERTURB RATIO: "<<this->deliveredQuantityRatio<<" "<<this->refuelRatio;
//      int b;cin>>b;


        neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
        vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();

        irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, this->refuelRatio, this->deliveredQuantityRatio);
        irps.fromSolutionToRepresentation(irps);
        irs = new InventoryRoutingSolution(irps);


        irp.evaluateSolution(*irs);

        cout<<"\n\nVALUE: "<<irs->getSolutionValue()<<"\n\n";
        if(irp.getIrpInstance().checkFeasibility(irs->getIrpSolution()))
            cout<<"\nNEIGH NOT FEASIBLE!\n";
        else{
            cout<<"\nNEIGH FEASIBLE!\n";
            this->numberFeasibleSolutions++;
            string filepath;
            filepath.append("./Neighborhood/");
            filepath.append(to_string(this->numberFeasibleSolutions));
            filepath.append("NeighSolution.xml");
            irs->getIrpSolution().saveSolution(filepath);
        }

    return dynamic_cast<Solution *> (irs);

    //if neighborhood is over return nullptr, else apply step
}


void emili::irp::irpRefuelNeighborhood::reset(){

    this->refuelRatio = REFUEL_INITIAL_VALUE;
    this->refuelStep = REFUEL_STEP;
    this->deliveredQuantityRatio = REFUEL_INITIAL_VALUE;
    this->deliveredQuantityStep = REFUEL_STEP;
    this->numberFeasibleSolutions = 0;
}

emili::Solution* emili::irp::irpRefuelNeighborhood::random(Solution* currentSolution){

    InventoryRoutingSolution *neighboringSolution = new InventoryRoutingSolution(*dynamic_cast<InventoryRoutingSolution *> (currentSolution));
    InventoryRoutingSolution *irs;

    double randomRefuel = generateRealRandomNumber();
    double randomDeliveredQuantity = generateRealRandomNumber();

    neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
    vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
    irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, randomRefuel, randomDeliveredQuantity);
    irs = new InventoryRoutingSolution(irps);
//    irs->getIrpSolution().fromSolutionToRepresentation(irs->getIrpSolution());

    return dynamic_cast<Solution *> (irs);
}

void emili::irp::irpRefuelNeighborhood::reverseLastMove(Solution * step){

    //invert last operation: apply move without updating indexes

    InventoryRoutingSolution *neighboringSolution = dynamic_cast<InventoryRoutingSolution *> (step);

    if(this->deliveredQuantityRatio > REFUEL_INITIAL_VALUE){
        this->deliveredQuantityRatio -= this->deliveredQuantityStep;
    }
    else if(this->refuelRatio > REFUEL_INITIAL_VALUE){
        this->deliveredQuantityRatio = 1.0;
        this->refuelRatio -= this->refuelStep;
    }

    neighboringSolution->getIrpSolution().fromSolutionToRepresentation(neighboringSolution->getIrpSolution());
    vector<unsigned int> representation = neighboringSolution->getIrpSolution().getRepresentation();
    irpSolution irps = this->irp.getIrpInstance().rebuildSolution(neighboringSolution->getIrpSolution(),representation, this->refuelRatio, this->deliveredQuantityRatio);
    InventoryRoutingSolution *irs = new InventoryRoutingSolution(irps);


}

int emili::irp::irpRefuelNeighborhood::size()
{
    return 1/(REFUEL_INITIAL_VALUE * REFUEL_INITIAL_VALUE);
}

emili::Solution* emili::irp::irpPerturbation::perturb(Solution* solution){

    InventoryRoutingSolution *perturbedSolution = new InventoryRoutingSolution(*dynamic_cast<InventoryRoutingSolution *> (solution));
    irpSolution irpPerturbedSolution = perturbedSolution->getIrpSolution();
}

// /home/antoniofisk/Desktop/Uni/MasterThesis/Project/build/Instance_V_1.1.xml IRP stin random
// /home/antoniofisk/Desktop/Uni/MasterThesis/Project/build/Instance_V_1.1.xml IRP best random locmin twoExc
// /home/antoniofisk/Desktop/Uni/MasterThesis/Project/build/Instance_V_1.1.xml IRP ILS first random locmin twoExc true rndmv twoExc 300 improve -it 300
